---
title: 设计模式逆向
date: 2022-04-10 16:26:17
categories:
- CS
- security
tags:
- security
toc: true
---
**设计模式的逆向特征**
<!-- more -->
# 一、创建型
## 1.工厂模式
* 单继承
![20220504114415](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504114415.png)
实际上单继承就是把 baseClass 的成员变量完全copy了一份放在了childClass的前面。
* 多继承
其实也都是成员变量按顺序往后排
* 虚函数与虚表
C++实现虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员保存了一个指针，这个指针叫虚表指针（vptr），它指向一个虚函数表（virtual function table, vtbl）。在运行时创建对象时，对象的虚表指针将设置为指向合适的虚表。如果该对象调用一个虚函数，则通过在该对象的虚表中进行查询来选择正确的函数。
每个类使用一个虚函数表，每个类对象用一个虚表指针。

对于包含虚函数的类，必须将一个虚表指针作为类中的第一个字段。在计算对象的总大小时，也必须考虑到虚表指针。这种情况在使用new操作符动态分配对象时最为明显，这时，传递给new的大小值不仅包括类（以及任何超类）中的所有显式声明的字段占用的空间，而且包括虚表指针所需的任何空间

![20220504120234](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504120234.png)
![20220504121338](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504121338.png)

* this指针
this可以看成是传递到所有非静态成员函数的第一个隐藏参数,Microsoft Visual C++利用thiscall调用约定，并将this传递到ECX寄存器中。
从逆向工程的角度看，在调用函数之前，将一个地址转移到ECX寄存器中可能意味着两件事情。首先，该文件使用Visual C++编译；其次，该函数是一个成员函数。如果同一个地址被传递给两个或更多函数，我们可以得到结论，这些函数全都属于同一个类层次结构。
如果发现一个函数向其他函数传递this指针，则这些函数可能和传递this的函数属于同一个类。

纯虚函数的标志

![20220504122033](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504122033.png)

main()用到AppleFactory 所以data段不会出现AppleFactory类

![20220504123508](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504123508.png)

## 2.单例模式
单例模式的构造函数是私有函数，但是在反汇编看不出私有属性。
* 类继承权限

类的继承权限并不会影响子类继承父类子类所拥有的父类的成员变量个数，换句话说，不管父类的成员变量是什么权限，子类都完全拥有一份父类的成员变量的拷贝

所以只能通过观察其属性成员是static定义的，大概率是单例模式

![20220504153132](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504153132.png)

release模式(静态成员的动态封装类)

![20220504153800](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504153800.png)

## 3.建造者模式
指导者类里含有一个建造者对象，建造者类里含有一个建造物对象
。可以通过看构造函数观察特征
另一个特征是director类会按照逻辑顺序依次调用builder类里的函数，如图
![20220504184629](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504184629.png)

![20220504161123](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504161123.png)

## 4.原型模式
* 实质就是找拷贝构造
![20220504191701](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504191701.png)

由此可见调用子类的拷贝构造函数会先调用父类的构造函数，然后在调用当前类的拷贝构造，这里的off_85600就是 vptr ，从虚函数表中也可以看见，子类覆盖了父类的虚函数就会指向子类的虚函数。

若没有覆盖，表项中依旧是指向父类的函数地址，而且顺序是按照父类的虚函数表顺序排列，子类中父类没有的虚函数会按顺序继续排在后面，不同类的虚函数表其实都是在编译期就已经确定了的，不同类的虚函数表处于临近的内存区域。

# 二、创建型
## 1.代理模式
* 代理类a包含被代理类b的实例，a,b类实现协议类protocol
* 代理类a和被代理类b接口相同

代理类a包含被代理类b的实例

![20220504193833](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504193833.png)

代理类接口的汇编，会发现call了被代理类的接口(实际情况应该会有相同的输入参数)

![20220504194058](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504194058.png)

## 2.装饰模式
* 分为若干个具体类和若干个装饰类，都是继承自同一个抽象类。
![20220504234255](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504234255.png)
* 每个装饰类都含有一个抽象类对象

* 每个装饰类都含有与抽象类有相同接口的虚函数，不同于具体类的虚函数是对抽象类的具体实现，装饰类的这个虚函数一定会调用抽象对象的虚函数，同时加上装饰类新增的自定义函数。

具体类对抽象类纯虚函数的实现

![20220504234546](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504234546.png)

装饰类的相同接口，调用了抽象对象(可以是父类指针指向子对象)的虚函数

![20220504234736](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504234736.png)
![20220504235143](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504235143.png)

实现了自定义的装饰

![20220504235010](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504235010.png)
![20220504235207](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220504235207.png)

## 3.适配器模式
* 将一个接口(已有接口类)转换成客户希望的另一个接口(用户接口类)
* 适配器类里会有一个已有接口类对象

![20220505000612](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505000612.png)

* 适配器类的父类是用户接口类(抽象类)

![20220505000217](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505000217.png)

* 适配器类虚函数是对用户接口类纯虚函数的具体实现，且里面一定会调用已有接口类的函数(且接口一般与该虚函数的接口不同)

![20220505001240](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505001240.png)

## 4.桥接模式
* 将抽象部分与它的实现部分分离,分为桥接类(抽象部分，如car)和实现类(实现部分，如enginee),两个大类各自可有抽象类和具体类。如图，找到了两个抽象类，分别为car和enginee

![20220505002300](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505002300.png)
* 桥接类的抽象类里含有实现类的抽象类对象
通过子类的构造函数找到了抽象类car的构造函数，改名为car::car,注意a2是enginee类强转到int64

![20220505002917](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505002917.png)
![20220505003116](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220505003116.png)

* 且两者纯虚函数接口相同，桥接类的虚函数具体实现一定会调用实现类对象的虚函数

![20220505010523](https://s2.loli.net/2022/05/05/8U2lCNdivGFnZOT.png)

## 5.组合模式
* 单个对象和组合对象继承自同个抽象类，接口一致，但实现可能不一致（如返回NULL）
![20220505011154](https://s2.loli.net/2022/05/05/iAHdsGeCNR93DS1.png)

* main函数定义的实例是树形对象，对象往往包含类似于装有抽象类对象的list容器

![20220505012644](https://s2.loli.net/2022/05/05/ITNE2RDnSjiHyqd.png)

如图，v20是根节点root,v19是子节点Dir,v18是子节点File

## 6.外观模式
* 外观类中有多个同层次的子系统类

直接查看Facade的构造函数，如果是系统自动定义的会显示表示出创建的成员对象,但在这里我们是通过new的方式的默认构造函数，所以会出现三行分配空间的代码，比较难读懂

可以转变思路，直接看Facade的函数，发现dothing函数里调用了三个子系统的dothing函数，说明外观类中有三个子系统类的对象

![20220505015659](https://s2.loli.net/2022/05/05/9ngz5NtJlBoIU1f.png)

## 7.享元模式
>>音乐服务根据收费划分出免费用户和会员用户，免费用户只能听部分免费音乐，会员用户可以听全部的音乐，并且可以下载。虽然权限上二者间有一些区别，但是他们所享受的音乐来是自于同一个音乐库，这样所有的音乐都只需要保存一份就可以了。另外如果出现音乐库里没有的音乐时，则需要新增该音乐，然后其他服务也可以享受新增的音乐，相当于享元池或缓存池的功能

可以动调，通过创建相同对象来看看享元池是否只保存了一次。或者输入条件相同时查询的是否是同一个对象。

![20220505030653](https://s2.loli.net/2022/05/05/XxnqQKh7GctFeDJ.png)

可看出数据结构进而推断出享元池的保存形式

![20220505030804](https://s2.loli.net/2022/05/05/hoSiwX7tkWZNcG8.png)

# 三、行为型
## 1.模板方法模式
* 抽象类里有模板函数来决定其他函数的执行顺序和逻辑

![20220505031426](https://s2.loli.net/2022/05/05/v87gM5womQaKVnR.png)
![20220505031510](https://s2.loli.net/2022/05/05/IwnXKqiZzcjrTFM.png)

## 2.命令模式
>>一个对象(Car)调用另一个对象(Engine)的过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。如果调用过程较繁琐，或者有多处调用，有必要用一个专门的类对这种调用过程进行封装，即command类

* 虽然有命令排序、批量提交等复杂操作，但本质还是看command类的特征
* command类(抽象类或具体类)一般包含一个要调用的目标对象

![20220505032458](https://s2.loli.net/2022/05/05/9rIoqLVgGeS4YPm.png)
* 命令的执行函数一定会调用目标对象的方法，一般比较繁琐或调用得比较多

![20220505032509](https://s2.loli.net/2022/05/05/Ofw6RCMq2E3xSlo.png)

## 3.职责链模式
* 子类完全平等，即哪个都有可能是下一个事件，即所有类都会有一个设置下一个处理单元的函数，(可能在抽象类实现然后继承抽象类)且参数必须是抽象类

![20220505033539](https://s2.loli.net/2022/05/05/NDdB21tOaxhwV84.png)
![20220505033608](https://s2.loli.net/2022/05/05/7REzTJGWBUFt1yw.png)
* 一般抽象类或子类会有一个抽象类对象，来作为下一个处理单元

![20220505033635](https://s2.loli.net/2022/05/05/eq9RiocuwVjsMIg.png)
* 子类的执行函数Handle()里会调用下一个处理单元的执行函数,即调用了相同的函数(除非恰好到了最后一个任务，下一个是结束任务NULL)

## 4.策略模式
>>定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化

* 要做到可替换性，实现类含有的策略类对象或函数参数一定要是抽象类
![20220505034810](https://s2.loli.net/2022/05/05/95MfPKOZISJ4HQo.png)

## 5.中介者模式
>>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互
* 中介者类一般含有多个相同的抽象类或子类，或者是装着这些类的容器等，一般是一对一或一对多
* 中介者类的函数方法会用到这些其他类的对象以实现交互

![20220505035650](https://s2.loli.net/2022/05/05/yn4632JvpIfgRaD.png)
* 其他的对象可能含有一个中介者类对象，且会用到中介者类的函数，并把自身的类作为参数传进去，以实现交互
![20220505040147](https://s2.loli.net/2022/05/05/RKZofGWDHwpkLv4.png)
![20220505040608](https://s2.loli.net/2022/05/05/K2pc7HPfgXNeRvz.png)

## 6.观察者模式
>>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
* 一般通知者类里会有一个装有被通知者类对象的容器
![20220505111851](https://s2.loli.net/2022/05/05/E94VWXBYF7ZNu3f.png)

* 通知者类的执行函数会遍历容器内的每一个被通知者类对象，并调用被通知者类对象函数(找循环)
![20220505112011](https://s2.loli.net/2022/05/05/xjCpqLinteTVmBZ.png)

## 7.备忘录模式
* 分为原发器类和存档类，两者的成员大体相同(看构造函数)

![20220505115025](https://s2.loli.net/2022/05/05/PkL4nfEqmNaDo2U.png)
![20220505115037](https://s2.loli.net/2022/05/05/1jTLxslrcNqdaI3.png)

* 原发器类含有一个存档函数和读档函数，分别以存档类对象作为返回值和函数参数。且调用的都是原发器类中的函数方法，存档类对象一般只作为参数和返回值

![20220505114541](https://s2.loli.net/2022/05/05/jRnktLsJHzG64Xc.png)
![20220505114734](https://s2.loli.net/2022/05/05/iv5d6gKy1mUYHfR.png)

* main函数多次调用存档-读档函数，且用对象自身上一个状态来调用存档函数，保存到一个存档类对象中，然后修改属性变动到下一个状态。若要读档，则把该存档类对象作为读档函数的参数。

## 8.访问者模式
* 包含访问者和被访问元素两个主要组成部分，被访问的元素通常具有不同的类型(或不同的子类)

![20220505123903](https://s2.loli.net/2022/05/05/bxhzVS7F9ZdA6en.png)
* 一般接收的函数参数是抽象类指针，然后根据不同的访问者可以对它们进行不同的访问操作。

![20220505123943](https://s2.loli.net/2022/05/05/a5YMyW6LoFzKqZe.png)

* 被访问的元素通常是只读的，写操作如下(把某个值写进了某个地址)。或者可以动态调试下，看某个地址存储的内容在程序执行过程中有无改变

![4419dcab47161c17824f5b3297fd03c](https://s2.loli.net/2022/05/10/Vh1c4SsnuUCN39P.png)

## 9.状态模式
* 分为对象类和状态类，对象类中含有一个状态类对象，表示对象当前状态，且有设置状态和得到状态等函数方法

![20220505141053](https://s2.loli.net/2022/05/05/eFxjys91uTDn2M4.png)
![20220505141147](https://s2.loli.net/2022/05/05/HcjZ8FlyiRW5EDf.png)
![20220505141230](https://s2.loli.net/2022/05/05/IY4Xv8uHr5ClAZb.png)
* 在状态类里实现对象类具体要做的功能，功能函数以对象类对象作为函数参数。状态类的不同子类表示不同的状态

![20220505141258](https://s2.loli.net/2022/05/05/Pog2GT15ZVk86pb.png)
* 功能函数会判断对象类对象的当前状态是否应该是该子类状态，如果不是就设置对象类对象的状态为下一个状态，并再次调用下一个状态的功能函数来判断。子类的功能函数高度相似，只是状态之间是环形结构

![20220505141346](https://s2.loli.net/2022/05/05/aYUICgX8pGytmbH.png)
![20220505141441](https://s2.loli.net/2022/05/05/zWLGfapwB2oZctJ.png)
![20220505141455](https://s2.loli.net/2022/05/05/rMifneWLXRc6uSN.png)

## 10.解释器模式
* 分为语言类和解释器类，解释器类的子类表示不同的解释方法。
* 解释器类的解释函数以语言类对象作为函数参数
  
![20220505143656](https://s2.loli.net/2022/05/05/IyETYtwpbMx84Pj.png)

## 11.迭代器模式
* 迭代器可理解为指针，迭代器类里存有数组类的对象指针和一个游标表示迭代器当前所指向的位置

![20220505150035](https://s2.loli.net/2022/05/05/h6tCsKPAzpVXawc.png)
* 数组类类似数据库，函数方法只实现存储和返回数据等功能

![20220505150129](https://s2.loli.net/2022/05/05/4kad37Ecwz2bXgB.png)
* 迭代器类有Next函数表示游标的移动

![20220505150154](https://s2.loli.net/2022/05/05/PacjC6oKZbTe23I.png)
* 创建迭代器的函数方法在数组类里

![20220505150110](https://s2.loli.net/2022/05/05/GFHBkrDd5hRVxAv.png)