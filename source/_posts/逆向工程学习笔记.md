---
title: 逆向工程学习笔记
date: 2022-04-19 19:15:14
categories:
- CS
- security
tags:
- reverse
- pwn
toc: true
---
**摘要：本文记录了学习逆向的过程**
<!-- more -->
# 前言

---
# 一.前置知识
## 1.什么是逆向
```
一般的编译：高级语言->汇编->机器码
逆向：机器码->汇编->源代码(高级语言)
从源代码理解开发者行为与目的
狭义的逆向：利用工具对源代码及二进制文件进行逆向分析
```
## 2.逆向工具
![20220419192055](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220419192055.png)

提前要记住IDA的基操~~
```
1.shift+F12 查看string信息 (通常可以看到重要的信息 )
2.Alt + T 查找带有目标字符串的函数
3. F5 查看 C代码
4. Ctrl + F 在函数框中 搜索函数
5. 空格键 流程图与代码 来回切换
```
## 3.逆向流程
`拿到程序->die看有没有壳，有的话脱壳->静态或动态分析`

## 4.其他
### PE和ELF
PE（Portable Executable）意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE格式文件，即`Windows`操作系统上的程序文件（可能是间接被执行，如DLL）

ELF（Executable and Linkable Format）意为可执行与可链接格式，一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是`Linux`的主要可执行文件格式。

### x86和x64的区别
x86中只有8个32位通用寄存器，eax,ebx,ecx，edx, ebp, esp, esi, edi。x86_64把这8个通用寄存器扩展成了64位的，并且比x86增加了若干个寄存器（增加了8个，变成了总共16个通用寄存器）

## AT&T和Intel
AT&T 语法，源在目标之前，而在英特尔语法中，目标在源之前

# 二、从零开始学逆向
## x86
### 1.恶意软件的类型
后门是一种将自身嵌入到计算机中的恶意代码，允许远程攻击者在`很少或有时没有权限`的情况下访问任何相应的本地计算机上的各种`命令`。

僵尸网络:攻击者通过各种途径传播`僵尸程序`感染互联网上的大量主机，而被感染的主机将通过一个控制信道接收攻击者的指令，从而在控制者和被感染主机之间所形成的一个可`一对多控制`的网络。僵尸网络为 DDoS 攻击提供了所需的“火力”带宽和计算机以及管理攻击所需的基础架构。“控制服务器（Control Server）”是指控制和通信的中心服务器
![20220420090903](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420090903.png)

下载器(downloader):是恶意代码，其目的只有一个，即安装其他恶意软件。当黑客最初获得对系统的访问权限时，经常会安装下载器。然后下载器安装额外的软件来控制系统

信息访问恶意软件:从计算机收集信息并将其直接发送到主机，例如键盘记录器或密码抓取器，通常用于获取对可能非常敏感的各种在线帐户的访问权限

Rootkit:向用户隐藏自身的存在和其他恶意软件，使其极难定位。可以操纵进程，例如在 IP 扫描中隐藏其 IP，这样用户可能永远不会知道他们拥有连接到僵尸网络或其他远程计算机的直接套接字。

蠕虫：它会自我复制并追踪其他计算机。

### 2.x86 程序集介绍
关注 32 位架构，因为最终大多数恶意软件都将为此编写，以便感染尽可能多的系统。32 位应用程序/恶意软件将在 64 位系统上运行。

专注于 Linux 和基于控制台的编程，因为大多数专业服务器都使用 Linux，因此是恶意软件的最大威胁。

### 3.十六进制数系统
我们在二进制中了解到每个数字代表一个位。如果我们组合 8 位，我们得到一个字节。一个字节可以进一步细分为高 4 位和低 4 位。由于 4 位为您提供了从 0 到 15 的可能范围，因此基数为 16 的数字系统更易于使用。

在 x86 汇编中，用十六进制表示二进制数字表示比在任何其他数字系统中都容易得多。重要的是要了解每个十六进制数都是 4 位长或称为半字节

十六进制的加法如下。从这一点开始，所有十六进制数字将在数字旁边有一个“h”：

![20220420092147](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420092147.png)

### 4.字节、字、双字
一个字节是 8 位。两个字节称为一个字，两个字称为一个双字，它是四个字节（32 位），一个四字是八个字节（64 位）。

一个字节是 8 位。大小为 8 位的二进制数的数量是从 0 开始到 255 的 256 个值之一。0xffffd040 是 4 个字节并且是一个双字。(每个十六进制数字都是 4 位长)

![20220420093525](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420093525.png)

### 5.x86 基本架构
![20220420095325](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420095325.png)

CPU由4部分组成：

![20220420095405](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420095405.png)

获取指令：32 位 CPU 首先从内存中的特定地址获取一个双字，然后从内存中读取并加载到 CPU 中。此时，CPU 查看双字中的二进制位模式，并开始执行获取的机器指令指示它执行的过程。

在执行完一条指令后，CPU 会进入内存并按顺序取出下一条机器指令。CPU 有一个寄存器，称为 EIP 或指令指针，它包含要从内存中获取并执行的下一条指令的地址

如果我们控制 EIP 的流程，我们可以改变程序来做它不打算做的事情。这是恶意软件运行的一种流行技术。

### 6.通用寄存器
通用寄存器可用于保存任何类型的数据，这些数据在程序中已获得特定用途
```
EAX : 算术计算中使用的主寄存器。也称为累加器，因为它保存算术运算的结果和函数返回值。
EBX：基址寄存器。指向 DS 段中数据的指针。用于存放程序的基地址。
ECX：计数器寄存器通常用于保存一个值，该值表示一个进程要重复的次数。用于循环和字符串操作。
EDX：通用寄存器。另外用于 I/O 操作。此外将 EAX 扩展到 64 位。
ESI：源索引寄存器。指向 DS 寄存器所指向的段中的数据的指针。用作字符串和数组操作中的偏移地址。它保存从哪里读取数据的地址。
EDI：目标索引寄存器。指向由 ES 寄存器指向的段中的数据（或目标）的指针。用作字符串和数组操作中的偏移地址。它保存所有字符串操作的隐含写入地址。
EBP：基指针。指向堆栈上数据的指针（在 SS 段中）。它指向当前堆栈帧的底部。它用于引用局部变量。
ESP：堆栈指针（在 SS 段中）。它指向当前堆栈帧的顶部。它用于引用局部变量。
```
EAX、EBX、ECX 和 EDX 寄存器的低 2 个字节中的每一个都可以由 AX 引用，然后按名称细分为 AH、BH、CH 和 DH 用于高字节，AL、BL、CL 和 DL 用于低字节每个 1 个字节。此外，ESI、EDI、EBP 和 ESP 可以通过它们的 16 位等效项来引用，即 SI、DI、BP、SP。

![20220420100512](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420100512.png)
### 7.段寄存器
```
CS：代码段寄存器存储用于数据访问的代码段（.text 段）的基本位置。
DS：数据段寄存器存储用于数据访问的变量（.data 部分）的默认位置。
ES：在字符串操作期间使用的额外段寄存器。
SS：堆栈段寄存器存储堆栈段的基址，在隐式使用堆栈指针或显式使用基址指针时使用。
FS：额外段寄存器。
GS：额外的段寄存器。
```
每个段寄存器都是 16 位的，包含指向内存特定段开始的指针。CS 寄存器包含指向内存中代码段的指针。代码段是`指令代码存储在内存中的位置`。处理器根据` CS 寄存器值和指令指针 (EIP)寄存器`中包含的`偏移值`从内存中检索指令代码。请记住，`没有程序可以显式加载或更改 CS 寄存器`。当程序被分配一个内存空间时，处理器分配它的值。

DS、ES、FS 和 GS 段寄存器都是用来指向数据段的。四个`单独的数据段`中的每一个都帮助程序`分离数据元素，以确保它们不重叠`。程序使用段的适当指针值加载数据段寄存器，然后使用`偏移值`引用各个内存位置。

段寄存器被认为是操作系统的一部分，几乎在所有情况下都不能直接读取或更改。在保护模式平面模型（32 位的 x86 架构）中工作时，您的程序运行并接收 4GB 地址空间，任何 32 位寄存器都可以潜在地寻址 40 亿个内存位置中的任何一个，但定义的那些受保护区域除外

物理内存可能大于 4GB，但是 32 位寄存器只能表示 4,294,967,296 个不同的位置。如果您的计算机中有超过 4GB 的内存，则操作系统必须在内存中安排一个 4GB 区域

### 8.EIP寄存器
默认情况时,gdb和gcc输出的汇编都是AT&T格式的,但是它们都有方式转换为Intel格式
![20220420111916](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420111916.png)

### 9.指令代码处理
![20220420123548](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420123548.png)
![20220420123513](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420123513.png)
![20220420143107](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420143107.png)

在最左边，我们有相应的内存地址。在中间我们有操作码，最后在右边我们有相应的英特尔语法汇编语言。

检查内存地址80483de，我们在其中看到操作码b8 00 00 00 00。我们可以看到b8操作码对应右边的mov eax, 0x0指令。下一系列 00 00 00 00 代表值 0 的 4 个字节。我们看到mov eax, 0x0因此将 0 的值移动到 eax 中，因此代表上面的代码。请记住，IA-32 平台使用我们所谓的小端表示法。

假设有一个int类型的变量，位于地址0x200处，它的十六进制值为0x12345678
12是最高有效位，78是最低有效位

小端表示法：
```
0x200	0x201	0x202	0x203
78		56		34		12
```

### 10.如何编译程序
`.c->.s(汇编语言源代码)->.o(二进制对象文件)->链接器生成二进制可执行文件`

### 11.内核空间与用户空间
在 Linux 中，有两个不同的内存区域。在任何程序执行的内存的最底部，我们都有内核空间，它由调度程序部分和向量表组成。

在任何程序执行的内存的最顶端，我们都有用户空间，它由堆栈、堆和最后的代码组成

![20220420151835](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420151835.png)

### 12.寄存器寻址[bx+idata]
![20220420203835](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420203835.png)

### 13.cmov条件传送指令
```
cmp		%rsi,	%rdi
cmova	%rdx,	%rax	
```
如果RSI寄存器中的值大于RDI寄存器中的值，则把RAX寄存器中的值替换为RDX寄存器中的值。(at&t)
## ARM32
### 1.二进制加减法
![20220420214102](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420214102.png)

### 2.字长
这是我们的第一个字：
```
0x00000000
0x00000004
0x00000008
0x0000000C
str, r9, [r4] @
    将 r9 的内容存储到 r4 中的位置，如果 r9 有 0x02 十六进制，
    0x02 将被存储到位置 r4
```
### 3.寄存器
![20220420215133](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420215133.png)

### 4.CPSR寄存器(当前程序状态寄存器)
该寄存器共有 32 位。我们最关心的最高 4 个是：
```
位 31 – N = 负标志
位 30 – Z = 零标志
位 29 – C = 进位标志（无符号操作）
位 28 – V = 溢出标志（签名操作）
```
### 5.链接寄存器
链接寄存器 R14 用于保存函数调用的返回地址。

当 BL（带链接的分支）指令执行子程序调用时，链接寄存器设置为子程序返回地址。BL 跳转到代码中的另一个位置，完成后允许返回到 BL 代码部分之后的点。当子程序返回时，链接寄存器将地址返回给程序计数器。

链接寄存器不需要对包含堆栈的内存进行读写操作，通过重复调用小子程序可以节省相当多的执行时间。

当 BL 执行后，返回地址，即下一条要执行的指令的地址，被加载到 LR 或 R14链接寄存器 中。当子例程完成时，LR 被直接复制到 PC（程序计数器）或 R15 并且代码继续执行它在顺序代码源中的先前位置。

### 6.ARM 固件引导过程
第一次打开 Raspberry Pi 设备时会发生什么。

一旦 Pi 通电，图形处理器就会首先运行，因为处理器处于复位状态，GPU 开始执行代码。ROM 从 SD 卡读取并读取bootcode.bin，然后将其加载到 C2 缓存中的内存中，然后打开 RAM 的其余部分，然后再加载start.elf 。

start.elf是图形处理器的操作系统，它读取您可以修改的config.txt 。然后kernel.img被加载到内存中的0x8000中，这是 `Linux 内核`。

加载后，kernel.img打开 CPU 并开始在内存中的`0x8000处`运行。

如果需要，我们可以创建自己的kernel.img，我们可以将机器代码硬编码到文件中并替换原始映像，然后重新启动。请记住，ARM 字长为 32 位，从位 0 到 31,如编写以下内容：
```
FE FF FF EA
```
当 Pi 启动时，以下代码在到达kernel.img时会加载以下内容：
```
FE FF FF EA
@ 地址 0x8000, 0xfe 被加载。
@ 地址 0x8001, 0xff 被加载。
@ 地址 0x8002, 0xff 被加载。
@ 地址 0x8003, 0xea 被加载。
```
```
上面的代码有 3 个部分：(小端输入法从右往左读)
1）有条件的 - 设置为始终
2）操作码 - 分支
3）偏移量——在当前位置内移动多远
条件 – 位 31-28：0xe 或 1110
操作码 – 位 27-24：0xa 或 1010
偏移量 - 位 23-0 -2
```
### 7.冯诺依曼架构
这种架构的 CPU 芯片包含一个控制单元和算术逻辑单元（以及一些本地存储器）

ARM 是一种加载和存储机器，算术逻辑单元仅对寄存器本身和任何需要存储到 RAM 的数据进行操作，控制单元在内存和共享同一数据总线的寄存器之间移动数据。

![20220421002329](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421002329.png)

### 8.加减法
ADDS 与 ADD 相同，只是它在 CPSR 中相应地设置标志。

我们将 100十进制加到r1中，将4,294,967,295加到r2中。然后我们将 r1和r2添加到r0 中。

![20220421003121](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421003121.png)

我们看到10 hex的CPSR。二进制中的10 hex是00010000。0001意味着：
```
未设置负标志
零标志未设置
进位标志未设置
溢出标志集
```
注意：上面的代码中没有设置溢出标志的任何内容，但是在执行此二进制文件时它处于自然状态(1)。我们看到64 十六进制或100 十进制按预期移动到r1中。CPSR没有变化。
加法r0中的值是十进制100和十进制4294967295加在一起后的十进制99 。这怎么可能？加法中溢出了r0的 32 位寄存器。
如果我们检查CPSR，我们现在会看到20000010 hex或0010 0000 0000 0000 0000 0000 0001 0000 binary。我们只需要关注最重要的位0010
```
未设置负标志
零标志未设置
进位标志设置//执行adds后从0001->0010
溢出标志未设置
```
设置了进位标志并且没有设置溢出标志。这是为什么？

进位标志是两个无符号数相加并且结果大于保存它的寄存器时设置的标志。我们正在处理一个 32 位寄存器。我们也在处理无符号数，因此设置了CF并且OF未设置，因为OF​​ 标志处理的是有符号数。

砰！我们破解了它，看到r0是101，因此没有触发进位标志，并将CPSR保持在0x10 十六进制，这意味着0001 二进制

注意：有符号运算表示范围：$-2^{n-1} 到 2^{n-1}-1$
无符号运算表示范围：$0 到 2^{n}-1$

![20220421004045](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421004045.png)

ADC 与 ADD 相同，只是如果设置了进位标志(即此时CPSR的第29位为1)，结果会加 1。所以当我们使用 ADC 时，我们需要特别注意 CPSR 或状态寄存器。

好的，所以我们在r3和r4中将100 个十进制数和100 个十进制数相加，我们在r5中得到201个十进制数！有什么东西坏了吗？ADC 与 ADD 相同，只是之前`adds r0,r1,r2`使得进位标志被设置，所以我们在r5中得到了额外的 1 。

![20220421005719](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421005719.png)

ARM中的减法有四个指令，分别是SUB、SBC、RSB和RSC。当您在每个末尾添加 S 后缀时，例如 SUBS、SBCS、RSBS、RSCS，它会影响标志。

### 9.编译原理
编译过程是将 C++ 代码翻译成机器代码的地方。编译将我们的文本文件获取为 cpp 文件并将其转换为称为 obj 文件的中间格式(二进制生成文件)。创建一个抽象语法树，它是常量数据、变量和指令的转换。创建树后，将生成代码。这意味着我们现在有了 ARM CPU 将执行的机器代码。每个 cpp 文件（翻译单元）都将有自己的相应 obj 文件与之关联。 

编译之后是链接生成二进制可执行文件，除了 C++ 标准库之外，链接还需要我们的 obj 文件、我们的编译文件，并找到每个符号和函数的位置，并将它们全部链接到一个可执行文件中。   

## x64
### 1.调用约定
__fastcall 调用约定指定函数的参数将在可能的情况下在寄存器中传递。符号 (@) 是名称的前缀；参数列表中后跟字节数（十进制）的@符号作为名称的后缀。

![20220421085840](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421085840.png)

如果您有五个要传递的参数，例如 int a， int b， int c， int d， int e并且它是一个 WORD 长度，a将进入cx，b进入dx，c进入r8w，d进入 r9w 和e 入栈。
### 2.指针
```
mov rax, 0x10 //rax = 0x10
mov rbx, word ptr [rax] //rbx = *rax ,获取地址所引用的对象时
mov word ptr [rax], 0x66 //*(0x10) = 0x66
```
假设内存0x10内的值是0x20 ，因此rax指向0x10内的值，当您通过[rax]引用时，rbx值为0x20。将0x66的值放入0x10的内存位置。原来0x10内存位置内的值是0x20，因此内存内 0x10 处的新值将是0x66。

```
lea rbx, my_var //rbx = &(my_var),rbx是一个地址
```

### 3.加载有效地址
在 C++ 中，一个指针实际上添加了用户在某些内容增加时会看到的内容，但是它实际上是在引擎盖下将其向前移动 2 个字节，假设它是一个字长或 16 位或 2 个字节。一样。

在汇编中，每个字节都是可寻址的。例如：
```
lea rax, my_var
inc rax
mov word ptr [rax], rbx
```
假设0x20的值在rbx中。上述指令会将0x20的值放入非字边界，这将导致错误。您必须将rax增加 2 以确保不会发生这种情况。

### 4.数据段
数据段在内存中的堆而不是堆栈上分配内存，因为它们不是局部变量，它们在整个二进制文件中都是已知的。 
```
1)byte - 我们使用显然是 1 字节或 8 位的 db 表示法。
2)word - 我们使用 dw，长度为 2 个字节。
3）双字 - 我们使用 dd 来分配，它们有 4 个字节长。
4）四字 - 我们使用 8 字节长的 dq。
5)xmm word - 我们使用 16 字节长的 xmmword。
6)ymm word - 我们使用 32 字节长的 ymmword。
有一些与 CPU 分开的 SSE 数学寄存器，它们保存以下内容：
1)real4 - 这是一个单数或您认为的浮点数，因为它有 4 个字节长。
2)real8 - 这是一个双浮点，因为它有 8 个字节长。
```
### 5.SHL,SHR,ROL,ROR指令

### 6.汇编的编译
![20220421151811](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs![20220421151811](httpscdn.jsdelivr.netghzhangsx19PicBedimages_for_blogs20220421151811.png).png)
![20220421152938](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421152938.png)
![20220421153221](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421153221.png)
```
mov ax,0x0001
mov bx,0x0002
add ax,bx ;result is in ax
```
注意小端表示法

机器会自动选择较优的指令(即占用字节空间较小的)

因为d位(默认)是0即r/m是目标操作数ax。

汇编代码编译成机器码，注意汇编指令和CPU机器指令不完全对应，因为汇编语言有很多伪指令(比如一条指令机器会拆分成几个步骤)。伪指令是编译器定义的，是编译器对机器指令的封装
### 7.计算机的启动过程
![20220421154534](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421154534.png)
CPU随着时钟信号，从内存中读取指令

按下电源键时，电源给主板供电，CPU会收到一个复位信号，大部分寄存器清零，但代码`段寄存器`CS会被初始化为0xFFFF,同时指令指针寄存器IP初始化为0x0000。
实模式下CPU的寻址方式是把CS的值左移4位即0xFFFF0,再加上IP的值，构成一个20位的
物理地址0xFFFF0,这个地址指向主板上的一块特殊的芯片(BIOS芯片)
BIOS(基础输入输出系统),是一段固化在芯片中的程序。CPU初始化后执行的第一条指令就来自这里。功能主要是对硬件进行诊断和检测，如判断主板上是否安装了内存条、硬盘、显卡等，并初始化这些设备，当检测到重要设备缺失时，BIOS程序将在屏幕上显示提示信息。(蜂鸣器也会根据不同错误发出声音)检测正常后BIOS最后做的是从外部存储设备读取更多的指令交给CPU执行(如硬盘等)

### 8.引导扇区
BIOS从硬盘上的主引导扇区加载一段程序到内存的固定位置交给CPU执行，操作系统就是由这段程序加载进内存里形成指令的(如安装操作系统的硬盘、U盘、光盘等)，加载成功就形成了windows开机界面啦

我们要做的就是在计算机启动的过程中找一个位置把我们自己的程序塞进去让CPU执行。
启动过程中CPU首先执行BIOS程序(主板出厂时已经固化好了，我们很难修改它)，然后就是位于硬盘的主引导扇区了，硬盘的数据我们是可以修改的。如果我们把自己的程序放进主引导扇区再由bios载入内存，就可以执行了。这也是在不用操作系统的情况下让我们的程序运行起来的唯一方法。

主引导扇区位于硬盘什么位置呢？传统的机械硬盘由盘片、磁头和硬盘驱动器组成。盘片用涂有磁介质的铝合金组成，比采用塑料介质的软盘硬很多，所以叫硬盘。盘片被安装在高速转机上旋转(笔记本会慢些)，磁头负责在盘面上读写信息。

![20220421161914](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421161914.png)
![20220421161929](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421161929.png)

每个磁道又被划分为多个扇区，每个扇区通常是512个字节(4096),一个磁道通常划分为63个扇区，扇区是硬盘上组织数据的最小单位，因为内圈磁道周长比外圈小，但划分的扇区数和每个扇区的字节数都一样，所以外圈磁道的扇区存储数据的密度比内圈扇区低

为了在盘片上定位数据，磁道和扇区有编号

![20220421162448](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421162448.png)

硬盘的横截面：一个硬盘由多个盘片组成，盘片的上下两面都有一个磁头，这些磁头固定在同一个轴上，所以磁头号和盘面号是一个意思。磁头在写入数据时并不是把一个盘片的一个面写满再去写下个面的，因为移动磁头来切换磁道的速度比读写的速度慢得多。硬盘是先写满0面的0磁道，再写1面的0磁道，这样纵向地组织数据的。所以不同盘面的相同磁道可以抽象地看成是一个柱面。

![20220421163320](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421163320.png)

如果我们知道一段数据在硬盘上的柱面号、扇区号和磁头号，就可以在硬盘上定位到这段数据。这就是硬盘的CHS寻址方式

![20220421163507](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421163507.png)

### 9.主引导记录(Master Boot Record,MBR)
主引导扇区是位于硬盘的0柱(0道)、0面、1扇区的512字节存储空间，而MBR则为我们要写入的这512个字节的数据。而这512个字节是有严格的格式规范的。
1个地址代表1个字节的数据

注意：标志位55AA必不可少，因为不是所有硬盘的0柱0面1扇区都是用来作为主引导扇区的，只有以55AA结尾的BIOS程序才会把主引导扇区的数据识别为MBR载入内存

### 10.VHD虚拟硬盘
VHD是微软定义的一种虚拟硬盘文件。

LBA(逻辑区块寻址，Logical Block Address):CHS寻址方式比较麻烦，而且出现了固态硬盘，根本不存在柱面磁头和扇区

![20220421170551](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421170551.png)

对于固定大小的VHD文件分成两个部分：数据区和尾部。数据区的结构和物理磁盘相同，即数据区扇区和虚拟硬盘扇区顺序映射。所以VHD虚拟硬盘的主引导扇区就是文件的头512字节。我们只需把写好的程序放入VHD文件的头512个字节即可。


![5227ab07c14acb6fbdeded6c801ed1e](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs5227ab07c14acb6fbdeded6c801ed1e.jpg)
# 三、实战题目
## 1.ignite me
拿到exe文件，放到die中脱壳，发现是exe32为程序，所以放到32位的IDA中，
![20220419200241](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220419200241.png)
![20220419200951](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220419200951.png)
![20220420123608](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220420123608.png)

## 2.入门逆向
![20220421121036](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421121036.png)
这里看到v2和v59这就证明了这是两个数组的运算，所以我们应该将上面的字符串分成两个数组，分别从v2和v59开始
![20220421121102](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220421121102.png)

0x13u的u表示无符号数

## 3.logmein
从伪代码我们可以看到，解密所需要的密钥（v7）应该是字符串，但这里v7是LL型的（长长整形），所以在解密之前需要先将v7还原为字符。

这里转换并不复杂，只需将v7的值转换为hex（16进制）然后再转换为字符串，但由于字符是小端存储，所以转换成字符串后还需对字符串做倒置处理。


# 四、遇到的问题
## 1.反编译时positive sp value has been found
栈sp不平衡，在options->General->Disassembly显示栈指针，然后发现提示的语句有负值(显示为负，实际为正，即实际中栈指针ESP不能为正值)，修改上一条语句直至提示的语句的栈指针显示为正值

# 五、other
## 1.函数调用
![c78b76bd211d7eb1df20b090a436b18](https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogsc78b76bd211d7eb1df20b090a436b18.png)

我们将常量标签的内存地址移动到 edi 中，并将立即数 25 decimal 移动到数组的第二个索引中。这本质上是一个源代码破解，因为我们将原始值 8 更改为 25。

注意，一个数组的元素占据4个字节，地址+4

## 2.加壳
即真正的源代码被加密了，执行时先执行一段植入的代码对原始代码进行解密，然后才执行源代码
---
# 总结

---
# 参考资料

