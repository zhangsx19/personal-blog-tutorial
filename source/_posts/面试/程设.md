---
title: 
date: 2022-04-18 16:58:50
categories:
- security
tags:
- 
toc: true
---
**摘要：程设面试题收集**
<!-- more -->
---
# 一.
1.Java中接口和抽象类的作用？
答：
    接口和抽象类可以简化代码数量，实现设计和实现分离。比如说接口或抽象类是交通工具时，那么继承接口或抽象类就可以表示成汽车、自行车、摩托车等具体的实现。
2.c和c++的区别？：
还有C是一个结构化语言，它着重于实现输入、处理、输出的流程；而C++在C的基础上添加了面向对象的思想，它着重于根据实际问题构造契合的对象模型，将处理过程与对象个体拆分开来独立进行处理，由各个对象处理自己的过程。

3.组件技术 (如微软的COM技术 )对程序设计带来的作用什么？
组建技术提高了程序的可重用性，利用库函数来定制自己程序，模块化，效率更高。

4. 结构体能实现类似C++ 中的类功能吗，并简要举例说明吗，并简要举例说明。
结构体和类的实际区别就是面向过程和面向对象编程思路的区别：
C的结构体只是把数据变量给包裹起来了，并不涉及算法；而C++是把数据变量及对这些数据变量的相关算法给封装起来，并且给对这些数据和类不同的访问权限。
比如简易模拟学生成绩管理系统，就可以定义一个学生类数组来代替学生类

5.静态变量有什么特征呐
静态变量指在程序执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类变量。
生命周期长：局部静态变量与变量所处函数同生命周期；而全局静态变量与整个程序有着相同生命周期；
稳定性：其存储空间就会在编译时设定，并且其数值不会随着函数的调用和退出而发生变化

6.*C语言问const char*p 和char const p是否相同，
const char *p; // 声明一个指向字符或字符串常量的指针(p所指向的内容不可修改)
char const p;// 同上
char * const p;//声明一个指向字符或字符串的指针常量，即不可以修改p的值，也就是地址无法修改。
先看第一种，先看p,根据优先级它和结合，是指针，指向char类型，但是char前面有一个const修饰，所以p所指向的内容为const类型不可修改。
第二种：由于没有const *的运算，若出现const *的形式，则const实际上是修饰前面的，所以char const *p和const char *p一样。
第三种情况：const修饰的是p,p不能修改。

7.a，b两个数，如何在不申请新空间的前提下实现两个数字的交换（很基础的算法）
int a = 2,b=5;
//位运算方法 一个数被另一个数异或两次，就还是其本身。
a=a^b;
b=ab;//相当于ab^b,结果还是a
a=ab;//相当于ab^a,结果还是b
System.out.println(“a”+a+“b”+b);
int c = 3,d = 4;
//算数运算方法 求和法
c=c+d;//求和，分别减去其中一个数字，实现交换
d=c-d;
c=c-d;

8.c++中的重载函数的概念以及功能，虚函数和虚基类的作用
函数重载是一种特殊情况，C++允许在同一作用域中声明几个类似的同名函数，这些同名函数的形参列表（参数个数，类型，顺序）必须不同；常用来处理实现功能类似数据类型不同的问题。比如比较大小的函数可以根据传入参数的数据类型和个数不同进行重载。
虚函数的定义是在函数定义的最前加上关键词virtual来定义，主要的作用是在类的派生中产生动态调用的作用,即指向派生类的基类指针可以调用派生类的同名虚函数.
而采用virtual fun(参数表) = 0这种形式声明的函数叫纯虚函数,其特征是没有函数体,它的作用主要是用来作派生类的接口,一个类里只要有这样一个函数,这个类就叫抽象类,当抽象类派生出派生类,这个抽象类就叫虚基类,纯虚函数必须在派生类里被实现,否则,这个派生类就仍是一个抽象类.

9.C++垃圾回收机制
我们知道Java有垃圾回收(Gabage Collector)机制，但c++没有这样的机制，这导致C++中对动态存储的管理成为程序员的噩梦，不是吗？c++程序员经常遇到的是内存泄露(memory leak)和非法指针存取
替代方法：C++C++有析构函数、智能指针、引用计数去管理资源的释放，对GC的需求不迫切。

10.如果简历上写了java和C++，老师会问java和C++的内存泄漏，进而问到C++的智能指针和其原理；
在堆中分配的内存，在还没有将其释放掉的时候，就把所有能访问这块内存的方式都删掉（如指针重新赋值）；另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。
第一种情况，在Java种有垃圾回收机制（GC）的引入，已经得到了很好的解决。所以，Java中的内存泄漏主要指的是第二种情况。而C++则包含以上两种情况。
要避免这种情况下的内存泄露，要求我们以C/C++ 的内存管理思维来管理自己分配的内存。第一，是在声明对象引用之前，明确内存对象的有效作用域。在一个函数内有效的内存对象，应该声明为 local 变量，与类实例生命周期相同的要声明为实例变量……以此类推。第二，在内存对象不再需要时，记得手动将其引用置空。

11.如果话题引到STL的容器老师可能会问红黑树和迭代器；
红黑树也是二叉搜索树。那么它就满足二叉搜索树的性质，除此之外，他还有几个比较特殊的性质，了解这些，有助于我们后面的分析
红黑树是近似平衡的二叉查找树，它含有以下特性：
1.每个节点要么是红色，要么是黑色。
2.根节点必须是黑色
3.红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。
4.对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。
5.每个叶子节点都为黑色

vector封装数组/list封装链表/deque/map/set（两者都封装了二叉树）
vector：表示一段连续的内存地址，相当于数据结构的线性表的顺式表现
list：STL实现的双向链表，允许快速插入和删除，查找较慢；相当于数据结构的线性表的链式表现，含有两个指针（一个指示直接后继、一个指示直接前驱）
deque：允许首部插入，其他的都和vector一样
map：存在key/value
迭代器提供了对集合（容器）元素的操作能力，比如访问和遍历。迭代器模仿了C++的指针，可以有++运算，*，以及->运算符来访问容器里的元素。


---

